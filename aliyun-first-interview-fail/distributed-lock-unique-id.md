## 面试题

谈谈分布式锁、以及分布式全局唯一ID的实现比较？

## 解析

####Redis分布式锁
通过setnx+随机字符串获取锁:
```
SET resource_name my_random_value NX PX 30000
```
通过lua脚本释放锁:
```
-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
这种方式在单节点下可以使用，但缺乏高可用，通过redssion+redis集群可以实现高可用的分布式锁.

####Zookeeper分布式锁
zk分布式锁，在是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。
释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。

####分布式全局唯一ID  
数据库自增id：优点简单易用；缺点是基于单个数据库，不适合高并发。

UUID：优点没有依赖，本地生成；缺点太长，32位的char为64个字节，作为主键占用空间，没有有序性，不能产生顺序写，性能不好。

snowflake算法：64位，8个字节，时间戳+机器id+同一毫秒4096个序号，适合高并发。

